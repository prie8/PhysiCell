import os
import glob
import numpy as np
import pandas as pd
import sys
import matplotlib.pyplot as plt
import seaborn as sns  # Using seaborn for better boxplots
import argparse

# --- Configuration ---
# CSV file name generated by the single-run script
stats_csv_filename = "simulation_stats.csv"

# Metrics to analyze across runs
key_metrics = [
    "biofilm_live",
    "biofilm_pct_reduction_vs_initial",
    "probiotic_live_total",
]
# Metric to plot as time series overlay
time_series_metric = "biofilm_pct_reduction_vs_initial"

# Plotting Style & Colors (Refined)
plot_style = "seaborn-v0_8-whitegrid"
box_palette = "Set2"  # A nice pastel color palette for boxes
strip_marker = "o"
strip_size = 6
strip_alpha = 0.7
strip_color = "black"  # Or choose a specific color e.g. 'darkslateblue'
strip_edge_color = "white"  # Adds definition to points
strip_linewidth = 0.5
# ---------------------


def analyze_runs(run_pattern, output_plot_prefix):
    """
    Loads data from multiple simulation runs, calculates summary stats,
    and generates comparison plots.

    Args:
        run_pattern (str): Glob pattern to find run directories
                           (e.g., './run_*/' or './output_P*/').
        output_plot_prefix (str): Prefix for saving output plot files.
    """
    run_directories = sorted(glob.glob(run_pattern))

    if not run_directories:
        print(f"Error: No directories found matching pattern '{run_pattern}'.")
        return

    print(f"Found {len(run_directories)} run directories to analyze:")
    for d in run_directories:
        print(f"  - {d}")

    all_runs_data = []
    final_stats_list = []

    # --- Load Data From Each Run ---
    for i, run_dir in enumerate(run_directories):
        csv_path = os.path.join(run_dir, stats_csv_filename)
        if os.path.exists(csv_path):
            try:
                run_df = pd.read_csv(csv_path)
                run_df["run_id"] = i  # Add run identifier
                all_runs_data.append(run_df)
                # Store final row for summary stats
                final_stats_list.append(run_df.iloc[-1])
                print(f"  Loaded data from {run_dir}")
            except Exception as e:
                print(f"  Error loading {csv_path}: {e}")
        else:
            print(f"  Warning: Cannot find {stats_csv_filename} in {run_dir}")

    if not all_runs_data:
        print("\nError: No data loaded. Cannot generate summaries.")
        return

    # Combine data into a single DataFrame
    combined_df = pd.concat(all_runs_data, ignore_index=True)
    final_stats_df = pd.DataFrame(final_stats_list)

    # --- Calculate Summary Statistics for Final Time Point ---
    print("\n--- Summary Statistics Across Runs (Final Time Point) ---")
    summary = final_stats_df[key_metrics].agg(["mean", "median", "std", "min", "max"])
    print(summary)
    print("-" * 50)

    # --- Generate Plots ---
    print("Generating summary plots across runs...")
    num_runs = len(run_directories)
    try:
        plt.style.use(plot_style)  # Apply chosen style

        # Plot 1: Time Series Overlay for a Key Metric (No changes here)
        fig1, ax1 = plt.subplots(figsize=(10, 6))
        # MODIFIED: Use 'color' instead of 'palette' for individual run lines
        sns.lineplot(
            data=combined_df,
            x="time_min",
            y=time_series_metric,
            units="run_id",
            estimator=None,
            lw=1,
            alpha=0.4,
            ax=ax1,
            color="grey",  # Set explicit color
            # palette=['grey']*num_runs # REMOVED: Caused warning
        )
        # Mean line (unchanged)
        sns.lineplot(
            data=combined_df,
            x="time_min",
            y=time_series_metric,
            color="blue",
            lw=2.5,
            label="Mean Across Runs",
            ax=ax1,
            errorbar="sd",
        )  # Show mean and std deviation band
        ax1.set_title(
            f'{time_series_metric.replace("_", " ").title()} Over Time (Across {num_runs} Runs)'
        )
        ax1.set_xlabel("Time (min)")
        ax1.set_ylabel(time_series_metric.replace("_", " ").title())
        # Force legend creation even if only mean line explicitly labeled
        handles, labels = ax1.get_legend_handles_labels()
        if not handles:  # Add a dummy handle if needed for the mean label
            handles = [plt.Line2D([0], [0], color="blue", lw=2.5)]
            labels = ["Mean Across Runs"]
        ax1.legend(handles=handles, labels=labels)  # Display legend correctly
        # END Add/Modify legend handling
        plot1_filename = f"{output_plot_prefix}_timeseries_summary.png"
        # Adjust layout slightly before saving plot 1 too
        fig1.tight_layout(rect=[0, 0, 1, 0.96])  # Leave space for title
        plt.savefig(plot1_filename, dpi=150)
        plt.close(fig1)
        print(f"  Saved time series plot: {plot1_filename}")
        # Plot 2: Box Plots + Strip Plot for Final Key Metrics (Refined & Fixed Warning)
        num_metrics = len(key_metrics)
        fig2, axs2 = plt.subplots(
            1, num_metrics, figsize=(5 * num_metrics, 5.5), sharey=False
        )  # Slightly taller figure
        if num_metrics == 1:  # Handle case of single metric
            axs2 = [axs2]

        # Get colors from the chosen palette BEFORE the loop
        palette_colors = sns.color_palette(box_palette, n_colors=num_metrics)

        for idx, metric in enumerate(key_metrics):
            # Box plot with chosen palette color assigned explicitly
            sns.boxplot(
                data=final_stats_df,
                y=metric,
                ax=axs2[idx],
                color=palette_colors[idx],  # MODIFIED: Use explicit color per plot
                # palette=box_palette, # REMOVED: This caused the warning
                linewidth=1.5,
                medianprops={"color": "black", "linewidth": 2},
                whiskerprops={"linestyle": "--", "linewidth": 1},
                capprops={"linewidth": 1},
            )
            # Strip plot overlay with refined style
            sns.stripplot(
                data=final_stats_df,
                y=metric,
                ax=axs2[idx],
                color=strip_color,
                marker=strip_marker,
                s=strip_size,
                alpha=strip_alpha,
                edgecolor=strip_edge_color,
                linewidth=strip_linewidth,
            )
            axs2[idx].set_title(f"Final {metric.replace('_', ' ').title()}")
            axs2[idx].set_ylabel(metric.replace("_", " ").title())
            axs2[idx].set_xlabel(f"{num_runs} Runs")

        # Main title for the figure
        fig2.suptitle(
            f"Distribution of Final Outcomes Across {num_runs} Runs",
            y=0.98,
            fontsize=14,
            fontweight="bold",
        )

        # Adjust layout carefully to prevent title overlap
        fig2.tight_layout(rect=[0.03, 0.03, 0.97, 0.93])

        plot2_filename = f"{output_plot_prefix}_final_distribution_refined.png"
        plt.savefig(plot2_filename, dpi=150)
        plt.close(fig2)
        print(f"  Saved refined final distribution plot: {plot2_filename}")

    except Exception as e:
        print(f"\nError generating plots: {e}")
        print("Ensure matplotlib and seaborn are installed.")

    print("-" * 50)
    print("Summary generation complete.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Summarize and plot results across multiple PhysiCell runs."
    )
    parser.add_argument(
        "run_pattern",
        type=str,
        help="Glob pattern to find run directories (e.g., './run_*/' or './output_P*/'). Remember quotes for wildcards.",
    )
    parser.add_argument(
        "-o",
        "--output_prefix",
        type=str,
        default="summary_across_runs",
        help="Prefix for output plot filenames.",
    )

    args = parser.parse_args()

    analyze_runs(args.run_pattern, args.output_prefix)
